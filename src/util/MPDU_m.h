//
// Generated file, do not edit! Created by nedtool 4.6 from util/MPDU.msg.
//

#ifndef _MPDU_M_H_
#define _MPDU_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
    #include "MACAddressExt.h"
    #include "IEEE802154Fields.h"
    #include "IEEE802154Enum.h"
// }}

/**
 * Class generated from <tt>util/MPDU.msg:46</tt> by nedtool.
 * <pre>
 * // see the generated C++ header for more info
 * packet mpdu
 * {
 *     unsigned short fcs;         // 16-Bit Frame Check Sequence
 *     Ash ash;                    // Auxiliary Security Header
 *     // ... MAC frame payload is encapsulated ...
 *     MACAddressExt src;          // 0, 16 or 64-Bit Source Address
 *     unsigned short srcPANid;    // 0 or 16-Bits for Source PAN Identifier
 *     MACAddressExt dest;         // 0, 16 or 64-Bit Destination Address
 *     unsigned short destPANid;   // 0 or 16-Bits for Destination PAN Identifier
 *     unsigned char sqnr = 0;       // 8-Bit Sequence number
 *     unsigned short fcf = 0;       // 16-Bit Frame Control Field
 *     bool isGTS = false;		    // Added extra for GTS logic
 *     bool isIndirect = false;      // Added extra for indirect transmissions
 * }
 * </pre>
 */
class mpdu : public ::cPacket
{
  protected:
    unsigned short fcs_var;
    Ash ash_var;
    MACAddressExt src_var;
    unsigned short srcPANid_var;
    MACAddressExt dest_var;
    unsigned short destPANid_var;
    unsigned char sqnr_var;
    unsigned short fcf_var;
    bool isGTS_var;
    bool isIndirect_var;

  private:
    void copy(const mpdu& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const mpdu&);

  public:
    mpdu(const char *name=NULL, int kind=0);
    mpdu(const mpdu& other);
    virtual ~mpdu();
    mpdu& operator=(const mpdu& other);
    virtual mpdu *dup() const {return new mpdu(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getFcs() const;
    virtual void setFcs(unsigned short fcs);
    virtual Ash& getAsh();
    virtual const Ash& getAsh() const {return const_cast<mpdu*>(this)->getAsh();}
    virtual void setAsh(const Ash& ash);
    virtual MACAddressExt& getSrc();
    virtual const MACAddressExt& getSrc() const {return const_cast<mpdu*>(this)->getSrc();}
    virtual void setSrc(const MACAddressExt& src);
    virtual unsigned short getSrcPANid() const;
    virtual void setSrcPANid(unsigned short srcPANid);
    virtual MACAddressExt& getDest();
    virtual const MACAddressExt& getDest() const {return const_cast<mpdu*>(this)->getDest();}
    virtual void setDest(const MACAddressExt& dest);
    virtual unsigned short getDestPANid() const;
    virtual void setDestPANid(unsigned short destPANid);
    virtual unsigned char getSqnr() const;
    virtual void setSqnr(unsigned char sqnr);
    virtual unsigned short getFcf() const;
    virtual void setFcf(unsigned short fcf);
    virtual bool getIsGTS() const;
    virtual void setIsGTS(bool isGTS);
    virtual bool getIsIndirect() const;
    virtual void setIsIndirect(bool isIndirect);
};

inline void doPacking(cCommBuffer *b, mpdu& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, mpdu& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:61</tt> by nedtool.
 * <pre>
 * packet beaconFrame extends mpdu
 * {
 *     SuperframeSpec sfSpec;                  // Superframe specifications
 *     GTSDescriptor gtsList[7];
 *     PendingAddrFields paFields;             // includes numLong numShort and List
 * }
 * </pre>
 */
class beaconFrame : public ::mpdu
{
  protected:
    SuperframeSpec sfSpec_var;
    GTSDescriptor gtsList_var[7];
    PendingAddrFields paFields_var;

  private:
    void copy(const beaconFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const beaconFrame&);

  public:
    beaconFrame(const char *name=NULL, int kind=0);
    beaconFrame(const beaconFrame& other);
    virtual ~beaconFrame();
    beaconFrame& operator=(const beaconFrame& other);
    virtual beaconFrame *dup() const {return new beaconFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual SuperframeSpec& getSfSpec();
    virtual const SuperframeSpec& getSfSpec() const {return const_cast<beaconFrame*>(this)->getSfSpec();}
    virtual void setSfSpec(const SuperframeSpec& sfSpec);
    virtual unsigned int getGtsListArraySize() const;
    virtual GTSDescriptor& getGtsList(unsigned int k);
    virtual const GTSDescriptor& getGtsList(unsigned int k) const {return const_cast<beaconFrame*>(this)->getGtsList(k);}
    virtual void setGtsList(unsigned int k, const GTSDescriptor& gtsList);
    virtual PendingAddrFields& getPaFields();
    virtual const PendingAddrFields& getPaFields() const {return const_cast<beaconFrame*>(this)->getPaFields();}
    virtual void setPaFields(const PendingAddrFields& paFields);
};

inline void doPacking(cCommBuffer *b, beaconFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, beaconFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:68</tt> by nedtool.
 * <pre>
 * packet beaconNotify
 * {
 *     // SDU is encapsulated
 *     unsigned char BSN;                      // 0x00–0xff, beacon sequence number
 *     PAN_ELE PANDescriptor;                  // the PANDescriptor for the received beacon
 *     PendingAddrFields PendAddrSpec;         // includes numLong numShort and List
 *     unsigned char sduLength;                // 0 – aMaxBeaconPayloadLength (52) (which is aMaxPHYPacketSize (127) – aMaxBeaconOverhead (75))
 * }
 * </pre>
 */
class beaconNotify : public ::cPacket
{
  protected:
    unsigned char BSN_var;
    PAN_ELE PANDescriptor_var;
    PendingAddrFields PendAddrSpec_var;
    unsigned char sduLength_var;

  private:
    void copy(const beaconNotify& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const beaconNotify&);

  public:
    beaconNotify(const char *name=NULL, int kind=0);
    beaconNotify(const beaconNotify& other);
    virtual ~beaconNotify();
    beaconNotify& operator=(const beaconNotify& other);
    virtual beaconNotify *dup() const {return new beaconNotify(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getBSN() const;
    virtual void setBSN(unsigned char BSN);
    virtual PAN_ELE& getPANDescriptor();
    virtual const PAN_ELE& getPANDescriptor() const {return const_cast<beaconNotify*>(this)->getPANDescriptor();}
    virtual void setPANDescriptor(const PAN_ELE& PANDescriptor);
    virtual PendingAddrFields& getPendAddrSpec();
    virtual const PendingAddrFields& getPendAddrSpec() const {return const_cast<beaconNotify*>(this)->getPendAddrSpec();}
    virtual void setPendAddrSpec(const PendingAddrFields& PendAddrSpec);
    virtual unsigned char getSduLength() const;
    virtual void setSduLength(unsigned char sduLength);
};

inline void doPacking(cCommBuffer *b, beaconNotify& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, beaconNotify& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:77</tt> by nedtool.
 * <pre>
 * message CmdFrame extends mpdu
 * {
 *     int cmdType @enum(Ieee802154MacCmdType);// refer to IEEE802154Enum.h
 * 
 * }
 * </pre>
 */
class CmdFrame : public ::mpdu
{
  protected:
    int cmdType_var;

  private:
    void copy(const CmdFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CmdFrame&);

  public:
    CmdFrame(const char *name=NULL, int kind=0);
    CmdFrame(const CmdFrame& other);
    virtual ~CmdFrame();
    CmdFrame& operator=(const CmdFrame& other);
    virtual CmdFrame *dup() const {return new CmdFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getCmdType() const;
    virtual void setCmdType(int cmdType);
};

inline void doPacking(cCommBuffer *b, CmdFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, CmdFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:82</tt> by nedtool.
 * <pre>
 * message RealignCmd extends CmdFrame
 * {
 *     unsigned short PANId;
 *     unsigned short CoordShortAddr;
 *     unsigned int LogicalChannel;            // logical channel on which to start using new superframe configuration
 *     unsigned short ShortAddr;
 *     unsigned char ChannelPage;              // 0 - 31, channel page on which to start using new superframe configuration
 * }
 * </pre>
 */
class RealignCmd : public ::CmdFrame
{
  protected:
    unsigned short PANId_var;
    unsigned short CoordShortAddr_var;
    unsigned int LogicalChannel_var;
    unsigned short ShortAddr_var;
    unsigned char ChannelPage_var;

  private:
    void copy(const RealignCmd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RealignCmd&);

  public:
    RealignCmd(const char *name=NULL, int kind=0);
    RealignCmd(const RealignCmd& other);
    virtual ~RealignCmd();
    RealignCmd& operator=(const RealignCmd& other);
    virtual RealignCmd *dup() const {return new RealignCmd(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getPANId() const;
    virtual void setPANId(unsigned short PANId);
    virtual unsigned short getCoordShortAddr() const;
    virtual void setCoordShortAddr(unsigned short CoordShortAddr);
    virtual unsigned int getLogicalChannel() const;
    virtual void setLogicalChannel(unsigned int LogicalChannel);
    virtual unsigned short getShortAddr() const;
    virtual void setShortAddr(unsigned short ShortAddr);
    virtual unsigned char getChannelPage() const;
    virtual void setChannelPage(unsigned char ChannelPage);
};

inline void doPacking(cCommBuffer *b, RealignCmd& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RealignCmd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:91</tt> by nedtool.
 * <pre>
 * message GTSCmd extends CmdFrame
 * {
 *     GTSDescriptor GTSCharacteristics;
 * }
 * </pre>
 */
class GTSCmd : public ::CmdFrame
{
  protected:
    GTSDescriptor GTSCharacteristics_var;

  private:
    void copy(const GTSCmd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GTSCmd&);

  public:
    GTSCmd(const char *name=NULL, int kind=0);
    GTSCmd(const GTSCmd& other);
    virtual ~GTSCmd();
    GTSCmd& operator=(const GTSCmd& other);
    virtual GTSCmd *dup() const {return new GTSCmd(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual GTSDescriptor& getGTSCharacteristics();
    virtual const GTSDescriptor& getGTSCharacteristics() const {return const_cast<GTSCmd*>(this)->getGTSCharacteristics();}
    virtual void setGTSCharacteristics(const GTSDescriptor& GTSCharacteristics);
};

inline void doPacking(cCommBuffer *b, GTSCmd& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GTSCmd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:96</tt> by nedtool.
 * <pre>
 * message DisAssoCmd extends CmdFrame
 * {
 *     unsigned char DisassociateReason @enum(DisAssociateReason); // refer to IEEE802154Enum.h
 * }
 * </pre>
 */
class DisAssoCmd : public ::CmdFrame
{
  protected:
    unsigned char DisassociateReason_var;

  private:
    void copy(const DisAssoCmd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DisAssoCmd&);

  public:
    DisAssoCmd(const char *name=NULL, int kind=0);
    DisAssoCmd(const DisAssoCmd& other);
    virtual ~DisAssoCmd();
    DisAssoCmd& operator=(const DisAssoCmd& other);
    virtual DisAssoCmd *dup() const {return new DisAssoCmd(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getDisassociateReason() const;
    virtual void setDisassociateReason(unsigned char DisassociateReason);
};

inline void doPacking(cCommBuffer *b, DisAssoCmd& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DisAssoCmd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:101</tt> by nedtool.
 * <pre>
 * message AssoCmdreq extends CmdFrame
 * {
 *     DevCapability CapabilityInformation;
 * }
 * </pre>
 */
class AssoCmdreq : public ::CmdFrame
{
  protected:
    DevCapability CapabilityInformation_var;

  private:
    void copy(const AssoCmdreq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AssoCmdreq&);

  public:
    AssoCmdreq(const char *name=NULL, int kind=0);
    AssoCmdreq(const AssoCmdreq& other);
    virtual ~AssoCmdreq();
    AssoCmdreq& operator=(const AssoCmdreq& other);
    virtual AssoCmdreq *dup() const {return new AssoCmdreq(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual DevCapability& getCapabilityInformation();
    virtual const DevCapability& getCapabilityInformation() const {return const_cast<AssoCmdreq*>(this)->getCapabilityInformation();}
    virtual void setCapabilityInformation(const DevCapability& CapabilityInformation);
};

inline void doPacking(cCommBuffer *b, AssoCmdreq& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AssoCmdreq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:106</tt> by nedtool.
 * <pre>
 * message AssoCmdresp extends CmdFrame
 * {
 *     unsigned short shortAddress;
 *     unsigned short status @enum(MlmeAssociationStatus); // refer to IEEE802154Enum.h
 * }
 * </pre>
 */
class AssoCmdresp : public ::CmdFrame
{
  protected:
    unsigned short shortAddress_var;
    unsigned short status_var;

  private:
    void copy(const AssoCmdresp& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AssoCmdresp&);

  public:
    AssoCmdresp(const char *name=NULL, int kind=0);
    AssoCmdresp(const AssoCmdresp& other);
    virtual ~AssoCmdresp();
    AssoCmdresp& operator=(const AssoCmdresp& other);
    virtual AssoCmdresp *dup() const {return new AssoCmdresp(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getShortAddress() const;
    virtual void setShortAddress(unsigned short shortAddress);
    virtual unsigned short getStatus() const;
    virtual void setStatus(unsigned short status);
};

inline void doPacking(cCommBuffer *b, AssoCmdresp& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AssoCmdresp& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:112</tt> by nedtool.
 * <pre>
 * message AckFrame
 * {
 *     unsigned short fcs;     // 16-Bit Frame Check Sequence
 *     unsigned char sqnr;     // 8-Bit Sequence Number
 *     unsigned short fcf;     // 16-Bit Framce Control Field
 * }
 * </pre>
 */
class AckFrame : public ::cMessage
{
  protected:
    unsigned short fcs_var;
    unsigned char sqnr_var;
    unsigned short fcf_var;

  private:
    void copy(const AckFrame& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AckFrame&);

  public:
    AckFrame(const char *name=NULL, int kind=0);
    AckFrame(const AckFrame& other);
    virtual ~AckFrame();
    AckFrame& operator=(const AckFrame& other);
    virtual AckFrame *dup() const {return new AckFrame(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getFcs() const;
    virtual void setFcs(unsigned short fcs);
    virtual unsigned char getSqnr() const;
    virtual void setSqnr(unsigned char sqnr);
    virtual unsigned short getFcf() const;
    virtual void setFcf(unsigned short fcf);
};

inline void doPacking(cCommBuffer *b, AckFrame& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AckFrame& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:119</tt> by nedtool.
 * <pre>
 * message DisAssociation
 * {
 *     unsigned char DeviceAddrMode @enum(AddrMode);   // refer to IEEE802154Enum.h
 *     unsigned short DevicePANId;
 *     MACAddressExt DeviceAddress;
 *     unsigned char DisassociateReason @enum(DisAssociateReason); // refer to IEEE802154Enum.h
 *     bool TxIndirect;
 *     unsigned short status @enum(MACenum);
 *     unsigned char SecurityLevel;            // 0x00–0x07, compare Table 95 in Spec. 802.15.4-2006
 *     unsigned char KeyIdMode;                // 0x00–0x03, mode to identify the key to be used
 *     unsigned long KeySource;                // depending on KeyidMode max set of uint8_t[8]
 *     unsigned char KeyIndex;                 // 0x01–0xff, index of the key to be used
 * }
 * </pre>
 */
class DisAssociation : public ::cMessage
{
  protected:
    unsigned char DeviceAddrMode_var;
    unsigned short DevicePANId_var;
    MACAddressExt DeviceAddress_var;
    unsigned char DisassociateReason_var;
    bool TxIndirect_var;
    unsigned short status_var;
    unsigned char SecurityLevel_var;
    unsigned char KeyIdMode_var;
    unsigned long KeySource_var;
    unsigned char KeyIndex_var;

  private:
    void copy(const DisAssociation& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DisAssociation&);

  public:
    DisAssociation(const char *name=NULL, int kind=0);
    DisAssociation(const DisAssociation& other);
    virtual ~DisAssociation();
    DisAssociation& operator=(const DisAssociation& other);
    virtual DisAssociation *dup() const {return new DisAssociation(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getDeviceAddrMode() const;
    virtual void setDeviceAddrMode(unsigned char DeviceAddrMode);
    virtual unsigned short getDevicePANId() const;
    virtual void setDevicePANId(unsigned short DevicePANId);
    virtual MACAddressExt& getDeviceAddress();
    virtual const MACAddressExt& getDeviceAddress() const {return const_cast<DisAssociation*>(this)->getDeviceAddress();}
    virtual void setDeviceAddress(const MACAddressExt& DeviceAddress);
    virtual unsigned char getDisassociateReason() const;
    virtual void setDisassociateReason(unsigned char DisassociateReason);
    virtual bool getTxIndirect() const;
    virtual void setTxIndirect(bool TxIndirect);
    virtual unsigned short getStatus() const;
    virtual void setStatus(unsigned short status);
    virtual unsigned char getSecurityLevel() const;
    virtual void setSecurityLevel(unsigned char SecurityLevel);
    virtual unsigned char getKeyIdMode() const;
    virtual void setKeyIdMode(unsigned char KeyIdMode);
    virtual unsigned long getKeySource() const;
    virtual void setKeySource(unsigned long KeySource);
    virtual unsigned char getKeyIndex() const;
    virtual void setKeyIndex(unsigned char KeyIndex);
};

inline void doPacking(cCommBuffer *b, DisAssociation& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DisAssociation& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:133</tt> by nedtool.
 * <pre>
 * message Association
 * {
 *     MACAddressExt addr; // used different in request and response for coordinator // device addr
 *     DevCapability CapabilityInformation;
 *     unsigned char SecurityLevel;            // 0x00–0x07, compare Table 95 in Spec. 802.15.4-2006
 *     unsigned char KeyIdMode;                // 0x00–0x03, mode to identify the key to be used
 *     unsigned long KeySource;                // depending on KeyidMode max set of uint8_t[8]
 *     unsigned char KeyIndex;                 // 0x01–0xff, index of the key to be used
 * }
 * </pre>
 */
class Association : public ::cMessage
{
  protected:
    MACAddressExt addr_var;
    DevCapability CapabilityInformation_var;
    unsigned char SecurityLevel_var;
    unsigned char KeyIdMode_var;
    unsigned long KeySource_var;
    unsigned char KeyIndex_var;

  private:
    void copy(const Association& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Association&);

  public:
    Association(const char *name=NULL, int kind=0);
    Association(const Association& other);
    virtual ~Association();
    Association& operator=(const Association& other);
    virtual Association *dup() const {return new Association(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual MACAddressExt& getAddr();
    virtual const MACAddressExt& getAddr() const {return const_cast<Association*>(this)->getAddr();}
    virtual void setAddr(const MACAddressExt& addr);
    virtual DevCapability& getCapabilityInformation();
    virtual const DevCapability& getCapabilityInformation() const {return const_cast<Association*>(this)->getCapabilityInformation();}
    virtual void setCapabilityInformation(const DevCapability& CapabilityInformation);
    virtual unsigned char getSecurityLevel() const;
    virtual void setSecurityLevel(unsigned char SecurityLevel);
    virtual unsigned char getKeyIdMode() const;
    virtual void setKeyIdMode(unsigned char KeyIdMode);
    virtual unsigned long getKeySource() const;
    virtual void setKeySource(unsigned long KeySource);
    virtual unsigned char getKeyIndex() const;
    virtual void setKeyIndex(unsigned char KeyIndex);
};

inline void doPacking(cCommBuffer *b, Association& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, Association& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:143</tt> by nedtool.
 * <pre>
 * message AssociationRequest extends Association
 * {
 *     unsigned int LogicalChannel;            // logical channel on which to start using new superframe configuration
 *     unsigned char ChannelPage;              // 0 - 31, channel page on which to start using new superframe configuration
 *     unsigned char CoordAddrMode @enum(AddrMode);
 *     MACAddressExt CoordPANId;
 *     MACAddressExt CoordAddress;
 * }
 * </pre>
 */
class AssociationRequest : public ::Association
{
  protected:
    unsigned int LogicalChannel_var;
    unsigned char ChannelPage_var;
    unsigned char CoordAddrMode_var;
    MACAddressExt CoordPANId_var;
    MACAddressExt CoordAddress_var;

  private:
    void copy(const AssociationRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AssociationRequest&);

  public:
    AssociationRequest(const char *name=NULL, int kind=0);
    AssociationRequest(const AssociationRequest& other);
    virtual ~AssociationRequest();
    AssociationRequest& operator=(const AssociationRequest& other);
    virtual AssociationRequest *dup() const {return new AssociationRequest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getLogicalChannel() const;
    virtual void setLogicalChannel(unsigned int LogicalChannel);
    virtual unsigned char getChannelPage() const;
    virtual void setChannelPage(unsigned char ChannelPage);
    virtual unsigned char getCoordAddrMode() const;
    virtual void setCoordAddrMode(unsigned char CoordAddrMode);
    virtual MACAddressExt& getCoordPANId();
    virtual const MACAddressExt& getCoordPANId() const {return const_cast<AssociationRequest*>(this)->getCoordPANId();}
    virtual void setCoordPANId(const MACAddressExt& CoordPANId);
    virtual MACAddressExt& getCoordAddress();
    virtual const MACAddressExt& getCoordAddress() const {return const_cast<AssociationRequest*>(this)->getCoordAddress();}
    virtual void setCoordAddress(const MACAddressExt& CoordAddress);
};

inline void doPacking(cCommBuffer *b, AssociationRequest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AssociationRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:152</tt> by nedtool.
 * <pre>
 * message AssociationResponse extends Association
 * {
 *     // Short Address ist also stored in the long address
 *     unsigned short status @enum(MlmeAssociationStatus);     // refer to IEEE802154Enum.h    
 * }
 * </pre>
 */
class AssociationResponse : public ::Association
{
  protected:
    unsigned short status_var;

  private:
    void copy(const AssociationResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AssociationResponse&);

  public:
    AssociationResponse(const char *name=NULL, int kind=0);
    AssociationResponse(const AssociationResponse& other);
    virtual ~AssociationResponse();
    AssociationResponse& operator=(const AssociationResponse& other);
    virtual AssociationResponse *dup() const {return new AssociationResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getStatus() const;
    virtual void setStatus(unsigned short status);
};

inline void doPacking(cCommBuffer *b, AssociationResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AssociationResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:158</tt> by nedtool.
 * <pre>
 * message AssociationConfirm extends Association
 * {
 *     // Short Address ist also stored in the long address
 *     unsigned short status @enum(MlmeAssociationStatus);     // refer to IEEE802154Enum.h        
 * }
 * </pre>
 */
class AssociationConfirm : public ::Association
{
  protected:
    unsigned short status_var;

  private:
    void copy(const AssociationConfirm& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const AssociationConfirm&);

  public:
    AssociationConfirm(const char *name=NULL, int kind=0);
    AssociationConfirm(const AssociationConfirm& other);
    virtual ~AssociationConfirm();
    AssociationConfirm& operator=(const AssociationConfirm& other);
    virtual AssociationConfirm *dup() const {return new AssociationConfirm(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getStatus() const;
    virtual void setStatus(unsigned short status);
};

inline void doPacking(cCommBuffer *b, AssociationConfirm& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, AssociationConfirm& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:164</tt> by nedtool.
 * <pre>
 * message GTSMessage
 * {
 *     GTSDescriptor GTSCharacteristics;
 *     unsigned char SecurityLevel;            // 0x00–0x07, compare Table 95 in Spec. 802.15.4-2006
 *     unsigned char KeyIdMode;                // 0x00–0x03, mode to identify the key to be used
 *     unsigned long KeySource;                // depending on KeyidMode max set of uint8_t[8]
 *     unsigned char KeyIndex;                 // 0x01–0xff, index of the key to be used
 * }
 * </pre>
 */
class GTSMessage : public ::cMessage
{
  protected:
    GTSDescriptor GTSCharacteristics_var;
    unsigned char SecurityLevel_var;
    unsigned char KeyIdMode_var;
    unsigned long KeySource_var;
    unsigned char KeyIndex_var;

  private:
    void copy(const GTSMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GTSMessage&);

  public:
    GTSMessage(const char *name=NULL, int kind=0);
    GTSMessage(const GTSMessage& other);
    virtual ~GTSMessage();
    GTSMessage& operator=(const GTSMessage& other);
    virtual GTSMessage *dup() const {return new GTSMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual GTSDescriptor& getGTSCharacteristics();
    virtual const GTSDescriptor& getGTSCharacteristics() const {return const_cast<GTSMessage*>(this)->getGTSCharacteristics();}
    virtual void setGTSCharacteristics(const GTSDescriptor& GTSCharacteristics);
    virtual unsigned char getSecurityLevel() const;
    virtual void setSecurityLevel(unsigned char SecurityLevel);
    virtual unsigned char getKeyIdMode() const;
    virtual void setKeyIdMode(unsigned char KeyIdMode);
    virtual unsigned long getKeySource() const;
    virtual void setKeySource(unsigned long KeySource);
    virtual unsigned char getKeyIndex() const;
    virtual void setKeyIndex(unsigned char KeyIndex);
};

inline void doPacking(cCommBuffer *b, GTSMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GTSMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:173</tt> by nedtool.
 * <pre>
 * message GTSIndication extends GTSMessage
 * {
 *     unsigned short deviceAddr;
 * }
 * </pre>
 */
class GTSIndication : public ::GTSMessage
{
  protected:
    unsigned short deviceAddr_var;

  private:
    void copy(const GTSIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GTSIndication&);

  public:
    GTSIndication(const char *name=NULL, int kind=0);
    GTSIndication(const GTSIndication& other);
    virtual ~GTSIndication();
    GTSIndication& operator=(const GTSIndication& other);
    virtual GTSIndication *dup() const {return new GTSIndication(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getDeviceAddr() const;
    virtual void setDeviceAddr(unsigned short deviceAddr);
};

inline void doPacking(cCommBuffer *b, GTSIndication& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GTSIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:178</tt> by nedtool.
 * <pre>
 * message GTSConfirm
 * {
 *     GTSDescriptor gts;
 *     unsigned short status @enum(MACenum);       // refer to IEEE802154Enum.h
 * }
 * </pre>
 */
class GTSConfirm : public ::cMessage
{
  protected:
    GTSDescriptor gts_var;
    unsigned short status_var;

  private:
    void copy(const GTSConfirm& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GTSConfirm&);

  public:
    GTSConfirm(const char *name=NULL, int kind=0);
    GTSConfirm(const GTSConfirm& other);
    virtual ~GTSConfirm();
    GTSConfirm& operator=(const GTSConfirm& other);
    virtual GTSConfirm *dup() const {return new GTSConfirm(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual GTSDescriptor& getGts();
    virtual const GTSDescriptor& getGts() const {return const_cast<GTSConfirm*>(this)->getGts();}
    virtual void setGts(const GTSDescriptor& gts);
    virtual unsigned short getStatus() const;
    virtual void setStatus(unsigned short status);
};

inline void doPacking(cCommBuffer *b, GTSConfirm& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GTSConfirm& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:184</tt> by nedtool.
 * <pre>
 * packet GetRequest
 * {
 *     unsigned short PIBattr @enum(Attributes);   // refer to IEEE802154Enum.h
 *     unsigned short PIBind;
 * }
 * </pre>
 */
class GetRequest : public ::cPacket
{
  protected:
    unsigned short PIBattr_var;
    unsigned short PIBind_var;

  private:
    void copy(const GetRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetRequest&);

  public:
    GetRequest(const char *name=NULL, int kind=0);
    GetRequest(const GetRequest& other);
    virtual ~GetRequest();
    GetRequest& operator=(const GetRequest& other);
    virtual GetRequest *dup() const {return new GetRequest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getPIBattr() const;
    virtual void setPIBattr(unsigned short PIBattr);
    virtual unsigned short getPIBind() const;
    virtual void setPIBind(unsigned short PIBind);
};

inline void doPacking(cCommBuffer *b, GetRequest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GetRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:190</tt> by nedtool.
 * <pre>
 * packet GetConfirm extends GetRequest
 * {
 *     // also used for SET request and Confirm
 *     unsigned short status @enum(PhyPIB_Status); // refer to IEEE802154Enum.h
 *     double value;
 * }
 * </pre>
 */
class GetConfirm : public ::GetRequest
{
  protected:
    unsigned short status_var;
    double value_var;

  private:
    void copy(const GetConfirm& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const GetConfirm&);

  public:
    GetConfirm(const char *name=NULL, int kind=0);
    GetConfirm(const GetConfirm& other);
    virtual ~GetConfirm();
    GetConfirm& operator=(const GetConfirm& other);
    virtual GetConfirm *dup() const {return new GetConfirm(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getStatus() const;
    virtual void setStatus(unsigned short status);
    virtual double getValue() const;
    virtual void setValue(double value);
};

inline void doPacking(cCommBuffer *b, GetConfirm& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, GetConfirm& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:197</tt> by nedtool.
 * <pre>
 * message MLMEReset
 * {
 *     // also used for Confirm true is success
 *     bool setDefaultPIB;
 * }
 * </pre>
 */
class MLMEReset : public ::cMessage
{
  protected:
    bool setDefaultPIB_var;

  private:
    void copy(const MLMEReset& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MLMEReset&);

  public:
    MLMEReset(const char *name=NULL, int kind=0);
    MLMEReset(const MLMEReset& other);
    virtual ~MLMEReset();
    MLMEReset& operator=(const MLMEReset& other);
    virtual MLMEReset *dup() const {return new MLMEReset(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getSetDefaultPIB() const;
    virtual void setSetDefaultPIB(bool setDefaultPIB);
};

inline void doPacking(cCommBuffer *b, MLMEReset& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MLMEReset& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:203</tt> by nedtool.
 * <pre>
 * message RxEnableRequest
 * {
 *     bool DeferPermit;                       // true if requested operation can be deferred until next superframe
 * 
 *     // TODO needs to be defined in symbols to make it adapt to different PHYs
 *     simtime_t RxOnTime;                     // number of symbols measured from the start of the superframe before the receiver is to be enabled or disabled, 
 *                                             // a 24-Bit value, to be ignored for non-beacon-enabled PANs 
 *     unsigned int RxOnDuration;              // number of symbols for which the receiver is to be enabled
 * }
 * </pre>
 */
class RxEnableRequest : public ::cMessage
{
  protected:
    bool DeferPermit_var;
    simtime_t RxOnTime_var;
    unsigned int RxOnDuration_var;

  private:
    void copy(const RxEnableRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RxEnableRequest&);

  public:
    RxEnableRequest(const char *name=NULL, int kind=0);
    RxEnableRequest(const RxEnableRequest& other);
    virtual ~RxEnableRequest();
    RxEnableRequest& operator=(const RxEnableRequest& other);
    virtual RxEnableRequest *dup() const {return new RxEnableRequest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getDeferPermit() const;
    virtual void setDeferPermit(bool DeferPermit);
    virtual simtime_t getRxOnTime() const;
    virtual void setRxOnTime(simtime_t RxOnTime);
    virtual unsigned int getRxOnDuration() const;
    virtual void setRxOnDuration(unsigned int RxOnDuration);
};

inline void doPacking(cCommBuffer *b, RxEnableRequest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RxEnableRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:213</tt> by nedtool.
 * <pre>
 * message RxEnableConfirm
 * {
 *     int status @enum(RxEnableStatus);
 * }
 * </pre>
 */
class RxEnableConfirm : public ::cMessage
{
  protected:
    int status_var;

  private:
    void copy(const RxEnableConfirm& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RxEnableConfirm&);

  public:
    RxEnableConfirm(const char *name=NULL, int kind=0);
    RxEnableConfirm(const RxEnableConfirm& other);
    virtual ~RxEnableConfirm();
    RxEnableConfirm& operator=(const RxEnableConfirm& other);
    virtual RxEnableConfirm *dup() const {return new RxEnableConfirm(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getStatus() const;
    virtual void setStatus(int status);
};

inline void doPacking(cCommBuffer *b, RxEnableConfirm& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RxEnableConfirm& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:218</tt> by nedtool.
 * <pre>
 * message ScanRequest
 * {
 *     unsigned char ScanType @enum(ScanType); // refer to IEEE802154Enum.h
 *     unsigned int ScanChannels;              // 27-Bit indicating the channels to be scanned
 *     unsigned int ScanDuration;              // The time spent scanning each channel is 
 *     unsigned char ChannelPage;              // 0 - 31, channel page on which to perform scan
 *     unsigned char SecurityLevel;            // 0x00–0x07, compare Table 95 in Spec. 802.15.4-2006
 *     unsigned char KeyIdMode;                // 0x00–0x03, mode to identify the key to be used
 *     unsigned long KeySource;                // depending on KeyidMode max set of uint8_t[8]
 *     unsigned char KeyIndex;                 // 0x01–0xff, index of the key to be used
 * }
 * </pre>
 */
class ScanRequest : public ::cMessage
{
  protected:
    unsigned char ScanType_var;
    unsigned int ScanChannels_var;
    unsigned int ScanDuration_var;
    unsigned char ChannelPage_var;
    unsigned char SecurityLevel_var;
    unsigned char KeyIdMode_var;
    unsigned long KeySource_var;
    unsigned char KeyIndex_var;

  private:
    void copy(const ScanRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ScanRequest&);

  public:
    ScanRequest(const char *name=NULL, int kind=0);
    ScanRequest(const ScanRequest& other);
    virtual ~ScanRequest();
    ScanRequest& operator=(const ScanRequest& other);
    virtual ScanRequest *dup() const {return new ScanRequest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getScanType() const;
    virtual void setScanType(unsigned char ScanType);
    virtual unsigned int getScanChannels() const;
    virtual void setScanChannels(unsigned int ScanChannels);
    virtual unsigned int getScanDuration() const;
    virtual void setScanDuration(unsigned int ScanDuration);
    virtual unsigned char getChannelPage() const;
    virtual void setChannelPage(unsigned char ChannelPage);
    virtual unsigned char getSecurityLevel() const;
    virtual void setSecurityLevel(unsigned char SecurityLevel);
    virtual unsigned char getKeyIdMode() const;
    virtual void setKeyIdMode(unsigned char KeyIdMode);
    virtual unsigned long getKeySource() const;
    virtual void setKeySource(unsigned long KeySource);
    virtual unsigned char getKeyIndex() const;
    virtual void setKeyIndex(unsigned char KeyIndex);
};

inline void doPacking(cCommBuffer *b, ScanRequest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ScanRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:230</tt> by nedtool.
 * <pre>
 * message ScanConfirm
 * {
 *     unsigned char status @enum(ScanStatus); // refer to IEEE802154Enum.h
 *     unsigned char ScanType @enum(ScanType); // 0x00-0x03, refer to IEEE802154Enum.h
 *     unsigned char ChannelPage;              // 0 - 31, channel page on which to perform scan
 *     unsigned int UnscannedChannels;         // 27-Bit indicating which channels weren't scanned in the given request, not valid for ED scans
 *     unsigned short ResultListSize;          // range is implementation specific 
 *     unsigned char EnergyDetectList[];       // 0x00-0xff for each
 *     PAN_ELE PANDescriptorList[];           // Elements of PANDescriptor - compare Table 55 of Spec. 802.15.4-2006
 * }
 * </pre>
 */
class ScanConfirm : public ::cMessage
{
  protected:
    unsigned char status_var;
    unsigned char ScanType_var;
    unsigned char ChannelPage_var;
    unsigned int UnscannedChannels_var;
    unsigned short ResultListSize_var;
    unsigned char *EnergyDetectList_var; // array ptr
    unsigned int EnergyDetectList_arraysize;
    PAN_ELE *PANDescriptorList_var; // array ptr
    unsigned int PANDescriptorList_arraysize;

  private:
    void copy(const ScanConfirm& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ScanConfirm&);

  public:
    ScanConfirm(const char *name=NULL, int kind=0);
    ScanConfirm(const ScanConfirm& other);
    virtual ~ScanConfirm();
    ScanConfirm& operator=(const ScanConfirm& other);
    virtual ScanConfirm *dup() const {return new ScanConfirm(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getStatus() const;
    virtual void setStatus(unsigned char status);
    virtual unsigned char getScanType() const;
    virtual void setScanType(unsigned char ScanType);
    virtual unsigned char getChannelPage() const;
    virtual void setChannelPage(unsigned char ChannelPage);
    virtual unsigned int getUnscannedChannels() const;
    virtual void setUnscannedChannels(unsigned int UnscannedChannels);
    virtual unsigned short getResultListSize() const;
    virtual void setResultListSize(unsigned short ResultListSize);
    virtual void setEnergyDetectListArraySize(unsigned int size);
    virtual unsigned int getEnergyDetectListArraySize() const;
    virtual unsigned char getEnergyDetectList(unsigned int k) const;
    virtual void setEnergyDetectList(unsigned int k, unsigned char EnergyDetectList);
    virtual void setPANDescriptorListArraySize(unsigned int size);
    virtual unsigned int getPANDescriptorListArraySize() const;
    virtual PAN_ELE& getPANDescriptorList(unsigned int k);
    virtual const PAN_ELE& getPANDescriptorList(unsigned int k) const {return const_cast<ScanConfirm*>(this)->getPANDescriptorList(k);}
    virtual void setPANDescriptorList(unsigned int k, const PAN_ELE& PANDescriptorList);
};

inline void doPacking(cCommBuffer *b, ScanConfirm& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ScanConfirm& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:241</tt> by nedtool.
 * <pre>
 * packet OrphanIndication
 * {
 *     MACAddressExt OrphanAddress;            // Extended 64-bit IEEE address
 *     unsigned char SecurityLevel;            // 0x00–0x07, compare Table 95 in Spec. 802.15.4-2006           
 *     unsigned char KeyIdMode;                // 0x00–0x03, mode to identify the key to be used
 *     unsigned long KeySource;                // depending on KeyidMode max set of uint8_t[8]
 *     unsigned char KeyIndex;                 // 0x01–0xff, index of the key to be used
 * }
 * </pre>
 */
class OrphanIndication : public ::cPacket
{
  protected:
    MACAddressExt OrphanAddress_var;
    unsigned char SecurityLevel_var;
    unsigned char KeyIdMode_var;
    unsigned long KeySource_var;
    unsigned char KeyIndex_var;

  private:
    void copy(const OrphanIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OrphanIndication&);

  public:
    OrphanIndication(const char *name=NULL, int kind=0);
    OrphanIndication(const OrphanIndication& other);
    virtual ~OrphanIndication();
    OrphanIndication& operator=(const OrphanIndication& other);
    virtual OrphanIndication *dup() const {return new OrphanIndication(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual MACAddressExt& getOrphanAddress();
    virtual const MACAddressExt& getOrphanAddress() const {return const_cast<OrphanIndication*>(this)->getOrphanAddress();}
    virtual void setOrphanAddress(const MACAddressExt& OrphanAddress);
    virtual unsigned char getSecurityLevel() const;
    virtual void setSecurityLevel(unsigned char SecurityLevel);
    virtual unsigned char getKeyIdMode() const;
    virtual void setKeyIdMode(unsigned char KeyIdMode);
    virtual unsigned long getKeySource() const;
    virtual void setKeySource(unsigned long KeySource);
    virtual unsigned char getKeyIndex() const;
    virtual void setKeyIndex(unsigned char KeyIndex);
};

inline void doPacking(cCommBuffer *b, OrphanIndication& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, OrphanIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:250</tt> by nedtool.
 * <pre>
 * packet OrphanResponse extends OrphanIndication
 * {
 *     unsigned short ShortAddress;            // 16-bit short address allocated to the orphaned device if associated with coordinator
 *     bool AssociatedMember;                  // TRUE if orphaned device is associated with coordinator, FALSE otherwise
 * }
 * </pre>
 */
class OrphanResponse : public ::OrphanIndication
{
  protected:
    unsigned short ShortAddress_var;
    bool AssociatedMember_var;

  private:
    void copy(const OrphanResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const OrphanResponse&);

  public:
    OrphanResponse(const char *name=NULL, int kind=0);
    OrphanResponse(const OrphanResponse& other);
    virtual ~OrphanResponse();
    OrphanResponse& operator=(const OrphanResponse& other);
    virtual OrphanResponse *dup() const {return new OrphanResponse(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getShortAddress() const;
    virtual void setShortAddress(unsigned short ShortAddress);
    virtual bool getAssociatedMember() const;
    virtual void setAssociatedMember(bool AssociatedMember);
};

inline void doPacking(cCommBuffer *b, OrphanResponse& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, OrphanResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:256</tt> by nedtool.
 * <pre>
 * message StartRequest
 * {
 *     unsigned short PANId;                   // 0x0000-0xffff, PAN identifier 
 *     unsigned int LogicalChannel;            // logical channel on which to start using new superframe configuration
 *     unsigned char ChannelPage;              // 0 - 31, channel page on which to start using new superframe configuration
 *     unsigned int StartTime;                 // 0x000000–0xffffff, 24-bit value indicating time at which beacon transmission commences
 *     unsigned char BeaconOrder;              // 0 - 15, how often the beacon is transmitted
 *     unsigned char SuperframeOrder;          // 0 - BO or 15, length of the active period of the superframe
 *     bool PANCoordinator;                    // if true device becomes PAN coordinator of new PAN, if false device begins using new configuration
 *     bool BatteryLifeExtension;              // if true disable receiver for macBattLifeExtPeriods backoff periods after IFS following a beacon
 *     bool CoordRealignment;                  // if true coordinator realigment command is to be transmitted priod to changing superframe structure
 *     unsigned char CoordRealignSecurityLevel;// 0x00–0x07, security level used for realignment command
 *     unsigned char CoordRealignKeyIdMode;    // 0x00–0x03, mode to identify the key to be used
 *     unsigned long CoordRealignKeySource;    // depending on KeyidMode max set of uint8_t[8]
 *     unsigned char CoordRealignKeyIndex;     // 0x01–0xff, index of the key to be used
 *     unsigned char BeaconSecurityLevel;      // 0x00–0x07, security level used for beacon frames
 *     unsigned char BeaconKeyIdMode;          // 0x00–0x03, mode to identify the key to be used
 *     unsigned long BeaconKeySource;          // depending on KeyidMode max set of uint8_t[8]
 *     unsigned char BeaconKeyIndex;           // 0x01–0xff, index of the key to be used
 * }
 * </pre>
 */
class StartRequest : public ::cMessage
{
  protected:
    unsigned short PANId_var;
    unsigned int LogicalChannel_var;
    unsigned char ChannelPage_var;
    unsigned int StartTime_var;
    unsigned char BeaconOrder_var;
    unsigned char SuperframeOrder_var;
    bool PANCoordinator_var;
    bool BatteryLifeExtension_var;
    bool CoordRealignment_var;
    unsigned char CoordRealignSecurityLevel_var;
    unsigned char CoordRealignKeyIdMode_var;
    unsigned long CoordRealignKeySource_var;
    unsigned char CoordRealignKeyIndex_var;
    unsigned char BeaconSecurityLevel_var;
    unsigned char BeaconKeyIdMode_var;
    unsigned long BeaconKeySource_var;
    unsigned char BeaconKeyIndex_var;

  private:
    void copy(const StartRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const StartRequest&);

  public:
    StartRequest(const char *name=NULL, int kind=0);
    StartRequest(const StartRequest& other);
    virtual ~StartRequest();
    StartRequest& operator=(const StartRequest& other);
    virtual StartRequest *dup() const {return new StartRequest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getPANId() const;
    virtual void setPANId(unsigned short PANId);
    virtual unsigned int getLogicalChannel() const;
    virtual void setLogicalChannel(unsigned int LogicalChannel);
    virtual unsigned char getChannelPage() const;
    virtual void setChannelPage(unsigned char ChannelPage);
    virtual unsigned int getStartTime() const;
    virtual void setStartTime(unsigned int StartTime);
    virtual unsigned char getBeaconOrder() const;
    virtual void setBeaconOrder(unsigned char BeaconOrder);
    virtual unsigned char getSuperframeOrder() const;
    virtual void setSuperframeOrder(unsigned char SuperframeOrder);
    virtual bool getPANCoordinator() const;
    virtual void setPANCoordinator(bool PANCoordinator);
    virtual bool getBatteryLifeExtension() const;
    virtual void setBatteryLifeExtension(bool BatteryLifeExtension);
    virtual bool getCoordRealignment() const;
    virtual void setCoordRealignment(bool CoordRealignment);
    virtual unsigned char getCoordRealignSecurityLevel() const;
    virtual void setCoordRealignSecurityLevel(unsigned char CoordRealignSecurityLevel);
    virtual unsigned char getCoordRealignKeyIdMode() const;
    virtual void setCoordRealignKeyIdMode(unsigned char CoordRealignKeyIdMode);
    virtual unsigned long getCoordRealignKeySource() const;
    virtual void setCoordRealignKeySource(unsigned long CoordRealignKeySource);
    virtual unsigned char getCoordRealignKeyIndex() const;
    virtual void setCoordRealignKeyIndex(unsigned char CoordRealignKeyIndex);
    virtual unsigned char getBeaconSecurityLevel() const;
    virtual void setBeaconSecurityLevel(unsigned char BeaconSecurityLevel);
    virtual unsigned char getBeaconKeyIdMode() const;
    virtual void setBeaconKeyIdMode(unsigned char BeaconKeyIdMode);
    virtual unsigned long getBeaconKeySource() const;
    virtual void setBeaconKeySource(unsigned long BeaconKeySource);
    virtual unsigned char getBeaconKeyIndex() const;
    virtual void setBeaconKeyIndex(unsigned char BeaconKeyIndex);
};

inline void doPacking(cCommBuffer *b, StartRequest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, StartRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:277</tt> by nedtool.
 * <pre>
 * message StartConfirm
 * {
 *     unsigned short status @enum(MACenum);   // refer to IEEE802154Enum.h
 * }
 * </pre>
 */
class StartConfirm : public ::cMessage
{
  protected:
    unsigned short status_var;

  private:
    void copy(const StartConfirm& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const StartConfirm&);

  public:
    StartConfirm(const char *name=NULL, int kind=0);
    StartConfirm(const StartConfirm& other);
    virtual ~StartConfirm();
    StartConfirm& operator=(const StartConfirm& other);
    virtual StartConfirm *dup() const {return new StartConfirm(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getStatus() const;
    virtual void setStatus(unsigned short status);
};

inline void doPacking(cCommBuffer *b, StartConfirm& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, StartConfirm& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:282</tt> by nedtool.
 * <pre>
 * message SyncRequest
 * {
 *     unsigned int LogicalChannel;            // logical channel on which to start using new superframe configuration
 *     unsigned char ChannelPage;              // 0 - 31, channel page on which to start using new superframe configuration
 *     bool TrackBeacon;                       // true if synchronizing with every beacon, false if synchronize only with next beacon
 * }
 * </pre>
 */
class SyncRequest : public ::cMessage
{
  protected:
    unsigned int LogicalChannel_var;
    unsigned char ChannelPage_var;
    bool TrackBeacon_var;

  private:
    void copy(const SyncRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SyncRequest&);

  public:
    SyncRequest(const char *name=NULL, int kind=0);
    SyncRequest(const SyncRequest& other);
    virtual ~SyncRequest();
    SyncRequest& operator=(const SyncRequest& other);
    virtual SyncRequest *dup() const {return new SyncRequest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned int getLogicalChannel() const;
    virtual void setLogicalChannel(unsigned int LogicalChannel);
    virtual unsigned char getChannelPage() const;
    virtual void setChannelPage(unsigned char ChannelPage);
    virtual bool getTrackBeacon() const;
    virtual void setTrackBeacon(bool TrackBeacon);
};

inline void doPacking(cCommBuffer *b, SyncRequest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SyncRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:289</tt> by nedtool.
 * <pre>
 * message SyncIndication
 * {
 *     unsigned short LossReason @enum(MACenum);   // refer to IEEE802154Enum.h
 *     unsigned short PANId;                   // 0x0000–0xffff, PAN identifier
 *     unsigned int LogicalChannel;            // logical channel on which to start using new superframe configuration
 *     unsigned char ChannelPage;              // 0 - 31, channel page on which to start using new superframe configuration
 *     unsigned char SecurityLevel;            // 0x00–0x07, compare Table 95 in Spec. 802.15.4-2006           
 *     unsigned char KeyIdMode;                // 0x00–0x03, mode to identify the key to be used
 *     unsigned long KeySource;                // depending on KeyidMode max set of uint8_t[8]
 *     unsigned char KeyIndex;                 // 0x01–0xff, index of the key to be used
 * }
 * </pre>
 */
class SyncIndication : public ::cMessage
{
  protected:
    unsigned short LossReason_var;
    unsigned short PANId_var;
    unsigned int LogicalChannel_var;
    unsigned char ChannelPage_var;
    unsigned char SecurityLevel_var;
    unsigned char KeyIdMode_var;
    unsigned long KeySource_var;
    unsigned char KeyIndex_var;

  private:
    void copy(const SyncIndication& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SyncIndication&);

  public:
    SyncIndication(const char *name=NULL, int kind=0);
    SyncIndication(const SyncIndication& other);
    virtual ~SyncIndication();
    SyncIndication& operator=(const SyncIndication& other);
    virtual SyncIndication *dup() const {return new SyncIndication(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getLossReason() const;
    virtual void setLossReason(unsigned short LossReason);
    virtual unsigned short getPANId() const;
    virtual void setPANId(unsigned short PANId);
    virtual unsigned int getLogicalChannel() const;
    virtual void setLogicalChannel(unsigned int LogicalChannel);
    virtual unsigned char getChannelPage() const;
    virtual void setChannelPage(unsigned char ChannelPage);
    virtual unsigned char getSecurityLevel() const;
    virtual void setSecurityLevel(unsigned char SecurityLevel);
    virtual unsigned char getKeyIdMode() const;
    virtual void setKeyIdMode(unsigned char KeyIdMode);
    virtual unsigned long getKeySource() const;
    virtual void setKeySource(unsigned long KeySource);
    virtual unsigned char getKeyIndex() const;
    virtual void setKeyIndex(unsigned char KeyIndex);
};

inline void doPacking(cCommBuffer *b, SyncIndication& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, SyncIndication& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:301</tt> by nedtool.
 * <pre>
 * message PollRequest
 * {
 *     unsigned char CoordAddrMode @enum(AddrMode);    // addressing mode of the coordinator, 16-bit short or 64-bit extended address
 *     unsigned short CoordPANId;              // 0x0000–0xfffe, PAN identifier of the coordinator which is polled
 *     MACAddressExt CoordAddress;             // address, type as specified by CoordAddrMode
 *     unsigned char SecurityLevel;            // 0x00–0x07, compare Table 95 in Spec. 802.15.4-2006           
 *     unsigned char KeyIdMode;                // 0x00–0x03, mode to identify the key to be used
 *     unsigned long KeySource;                // depending on KeyidMode max set of uint8_t[8]
 *     unsigned char KeyIndex;                 // 0x01–0xff, index of the key to be used
 * }
 * </pre>
 */
class PollRequest : public ::cMessage
{
  protected:
    unsigned char CoordAddrMode_var;
    unsigned short CoordPANId_var;
    MACAddressExt CoordAddress_var;
    unsigned char SecurityLevel_var;
    unsigned char KeyIdMode_var;
    unsigned long KeySource_var;
    unsigned char KeyIndex_var;

  private:
    void copy(const PollRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PollRequest&);

  public:
    PollRequest(const char *name=NULL, int kind=0);
    PollRequest(const PollRequest& other);
    virtual ~PollRequest();
    PollRequest& operator=(const PollRequest& other);
    virtual PollRequest *dup() const {return new PollRequest(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getCoordAddrMode() const;
    virtual void setCoordAddrMode(unsigned char CoordAddrMode);
    virtual unsigned short getCoordPANId() const;
    virtual void setCoordPANId(unsigned short CoordPANId);
    virtual MACAddressExt& getCoordAddress();
    virtual const MACAddressExt& getCoordAddress() const {return const_cast<PollRequest*>(this)->getCoordAddress();}
    virtual void setCoordAddress(const MACAddressExt& CoordAddress);
    virtual unsigned char getSecurityLevel() const;
    virtual void setSecurityLevel(unsigned char SecurityLevel);
    virtual unsigned char getKeyIdMode() const;
    virtual void setKeyIdMode(unsigned char KeyIdMode);
    virtual unsigned long getKeySource() const;
    virtual void setKeySource(unsigned long KeySource);
    virtual unsigned char getKeyIndex() const;
    virtual void setKeyIndex(unsigned char KeyIndex);
};

inline void doPacking(cCommBuffer *b, PollRequest& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PollRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/MPDU.msg:312</tt> by nedtool.
 * <pre>
 * message PollConfirm
 * {
 *     unsigned short status @enum(MACenum);   // refer to IEEE802154Enum.h
 * }
 * </pre>
 */
class PollConfirm : public ::cMessage
{
  protected:
    unsigned short status_var;

  private:
    void copy(const PollConfirm& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PollConfirm&);

  public:
    PollConfirm(const char *name=NULL, int kind=0);
    PollConfirm(const PollConfirm& other);
    virtual ~PollConfirm();
    PollConfirm& operator=(const PollConfirm& other);
    virtual PollConfirm *dup() const {return new PollConfirm(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getStatus() const;
    virtual void setStatus(unsigned short status);
};

inline void doPacking(cCommBuffer *b, PollConfirm& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PollConfirm& obj) {obj.parsimUnpack(b);}


#endif // ifndef _MPDU_M_H_

