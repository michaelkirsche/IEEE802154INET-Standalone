//
// Generated file, do not edit! Created by nedtool 4.6 from util/mcpsData.msg.
//

#ifndef _MCPSDATA_M_H_
#define _MCPSDATA_M_H_

#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0406
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif



// cplusplus {{
    #include "IEEE802154Enum.h"
    #include "MACAddressExt.h" 
// }}

/**
 * Class generated from <tt>util/mcpsData.msg:32</tt> by nedtool.
 * <pre>
 * // This is the format that the SSCS layer should send to our MAC Entity
 * packet mcpsDataReq
 * {
 *     unsigned char SrcAddrMode @enum(AddrMode); // 0x00–0x03
 *     unsigned char DstAddrMode;         // 0x00–0x03
 *     unsigned short DstPANId;           // 0x0000–0xffff
 *     MACAddressExt DstAddr;
 *     unsigned char msduLength;          // <= aMaxMACPayloadSize
 *     //msdu, Payload just encapsulated
 *     unsigned long msduHandle;          // 0x00–0xff  -->  actually just an unsigned char 8-Bit value but mapping to OMNeT msg ID requires long
 *     unsigned char TxOptions;           // actuallay a 3-Bit field 000 - 111
 *     unsigned char SecurityLevel;	   // 0x00–0x07
 *     unsigned char KeyIdMode;           // 0x00–0x03
 *     unsigned long KeySource;           // depending on KeyidMode max set of uint8_t[8]			
 *     unsigned char KeyIndex;            // 0x01–0xff
 * }
 * </pre>
 */
class mcpsDataReq : public ::cPacket
{
  protected:
    unsigned char SrcAddrMode_var;
    unsigned char DstAddrMode_var;
    unsigned short DstPANId_var;
    MACAddressExt DstAddr_var;
    unsigned char msduLength_var;
    unsigned long msduHandle_var;
    unsigned char TxOptions_var;
    unsigned char SecurityLevel_var;
    unsigned char KeyIdMode_var;
    unsigned long KeySource_var;
    unsigned char KeyIndex_var;

  private:
    void copy(const mcpsDataReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const mcpsDataReq&);

  public:
    mcpsDataReq(const char *name=NULL, int kind=0);
    mcpsDataReq(const mcpsDataReq& other);
    virtual ~mcpsDataReq();
    mcpsDataReq& operator=(const mcpsDataReq& other);
    virtual mcpsDataReq *dup() const {return new mcpsDataReq(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getSrcAddrMode() const;
    virtual void setSrcAddrMode(unsigned char SrcAddrMode);
    virtual unsigned char getDstAddrMode() const;
    virtual void setDstAddrMode(unsigned char DstAddrMode);
    virtual unsigned short getDstPANId() const;
    virtual void setDstPANId(unsigned short DstPANId);
    virtual MACAddressExt& getDstAddr();
    virtual const MACAddressExt& getDstAddr() const {return const_cast<mcpsDataReq*>(this)->getDstAddr();}
    virtual void setDstAddr(const MACAddressExt& DstAddr);
    virtual unsigned char getMsduLength() const;
    virtual void setMsduLength(unsigned char msduLength);
    virtual unsigned long getMsduHandle() const;
    virtual void setMsduHandle(unsigned long msduHandle);
    virtual unsigned char getTxOptions() const;
    virtual void setTxOptions(unsigned char TxOptions);
    virtual unsigned char getSecurityLevel() const;
    virtual void setSecurityLevel(unsigned char SecurityLevel);
    virtual unsigned char getKeyIdMode() const;
    virtual void setKeyIdMode(unsigned char KeyIdMode);
    virtual unsigned long getKeySource() const;
    virtual void setKeySource(unsigned long KeySource);
    virtual unsigned char getKeyIndex() const;
    virtual void setKeyIndex(unsigned char KeyIndex);
};

inline void doPacking(cCommBuffer *b, mcpsDataReq& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, mcpsDataReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mcpsData.msg:47</tt> by nedtool.
 * <pre>
 * packet mcpsDataInd extends mcpsDataReq
 * {
 *     unsigned short SrcPANId;           // 0x0000–0xffff
 *     MACAddressExt SrcAddr;
 *     unsigned char mpduLinkQuality;     // 0x00–0xff
 *     unsigned char DSN;                 // 0x00–0xff	
 * 	//uint32_t Timestamp;              // 0x000000–0xffffff -> optional is set via ->setTimestamp()
 * }
 * </pre>
 */
class mcpsDataInd : public ::mcpsDataReq
{
  protected:
    unsigned short SrcPANId_var;
    MACAddressExt SrcAddr_var;
    unsigned char mpduLinkQuality_var;
    unsigned char DSN_var;

  private:
    void copy(const mcpsDataInd& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const mcpsDataInd&);

  public:
    mcpsDataInd(const char *name=NULL, int kind=0);
    mcpsDataInd(const mcpsDataInd& other);
    virtual ~mcpsDataInd();
    mcpsDataInd& operator=(const mcpsDataInd& other);
    virtual mcpsDataInd *dup() const {return new mcpsDataInd(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned short getSrcPANId() const;
    virtual void setSrcPANId(unsigned short SrcPANId);
    virtual MACAddressExt& getSrcAddr();
    virtual const MACAddressExt& getSrcAddr() const {return const_cast<mcpsDataInd*>(this)->getSrcAddr();}
    virtual void setSrcAddr(const MACAddressExt& SrcAddr);
    virtual unsigned char getMpduLinkQuality() const;
    virtual void setMpduLinkQuality(unsigned char mpduLinkQuality);
    virtual unsigned char getDSN() const;
    virtual void setDSN(unsigned char DSN);
};

inline void doPacking(cCommBuffer *b, mcpsDataInd& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, mcpsDataInd& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mcpsData.msg:56</tt> by nedtool.
 * <pre>
 * packet mcpsDataConf
 * {
 *     // added for MSCPS confirm 
 *     unsigned long msduHandle;          // 0x00–0xff  -->  actually just an unsigned char 8-Bit value but mapping to OMNeT msg ID requires long 
 *     unsigned char status @enum(MCPSStatus);    // see IEEE802154Enum.h
 * 	//uint32_t Timestamp;			   // 0x000000–0xffffff -> optional is set via ->setTimestamp()
 * }
 * </pre>
 */
class mcpsDataConf : public ::cPacket
{
  protected:
    unsigned long msduHandle_var;
    unsigned char status_var;

  private:
    void copy(const mcpsDataConf& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const mcpsDataConf&);

  public:
    mcpsDataConf(const char *name=NULL, int kind=0);
    mcpsDataConf(const mcpsDataConf& other);
    virtual ~mcpsDataConf();
    mcpsDataConf& operator=(const mcpsDataConf& other);
    virtual mcpsDataConf *dup() const {return new mcpsDataConf(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned long getMsduHandle() const;
    virtual void setMsduHandle(unsigned long msduHandle);
    virtual unsigned char getStatus() const;
    virtual void setStatus(unsigned char status);
};

inline void doPacking(cCommBuffer *b, mcpsDataConf& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, mcpsDataConf& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mcpsData.msg:63</tt> by nedtool.
 * <pre>
 * packet MaUnitdata
 * {
 *     MACAddressExt SrcAddr;
 *     MACAddressExt DstAddr;
 * 	// RoutingInformation NULL
 * 	// data 			encapsulated
 * 	// priority,
 * 	// ServiceClass // NULL 
 * }
 * </pre>
 */
class MaUnitdata : public ::cPacket
{
  protected:
    MACAddressExt SrcAddr_var;
    MACAddressExt DstAddr_var;

  private:
    void copy(const MaUnitdata& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MaUnitdata&);

  public:
    MaUnitdata(const char *name=NULL, int kind=0);
    MaUnitdata(const MaUnitdata& other);
    virtual ~MaUnitdata();
    MaUnitdata& operator=(const MaUnitdata& other);
    virtual MaUnitdata *dup() const {return new MaUnitdata(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual MACAddressExt& getSrcAddr();
    virtual const MACAddressExt& getSrcAddr() const {return const_cast<MaUnitdata*>(this)->getSrcAddr();}
    virtual void setSrcAddr(const MACAddressExt& SrcAddr);
    virtual MACAddressExt& getDstAddr();
    virtual const MACAddressExt& getDstAddr() const {return const_cast<MaUnitdata*>(this)->getDstAddr();}
    virtual void setDstAddr(const MACAddressExt& DstAddr);
};

inline void doPacking(cCommBuffer *b, MaUnitdata& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MaUnitdata& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mcpsData.msg:72</tt> by nedtool.
 * <pre>
 * message mcpsPurgeReq
 * {
 *     unsigned long msduHandle;          // 0x00–0xff  -->  actually just an unsigned char 8-Bit value but mapping to OMNeT msg ID requires long
 * }
 * </pre>
 */
class mcpsPurgeReq : public ::cMessage
{
  protected:
    unsigned long msduHandle_var;

  private:
    void copy(const mcpsPurgeReq& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const mcpsPurgeReq&);

  public:
    mcpsPurgeReq(const char *name=NULL, int kind=0);
    mcpsPurgeReq(const mcpsPurgeReq& other);
    virtual ~mcpsPurgeReq();
    mcpsPurgeReq& operator=(const mcpsPurgeReq& other);
    virtual mcpsPurgeReq *dup() const {return new mcpsPurgeReq(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned long getMsduHandle() const;
    virtual void setMsduHandle(unsigned long msduHandle);
};

inline void doPacking(cCommBuffer *b, mcpsPurgeReq& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, mcpsPurgeReq& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>util/mcpsData.msg:76</tt> by nedtool.
 * <pre>
 * message mcpsPurgeConf extends mcpsPurgeReq
 * {
 *     unsigned char status @enum(purgeStatus);   // see IEEE802154Enum.h
 * }
 * </pre>
 */
class mcpsPurgeConf : public ::mcpsPurgeReq
{
  protected:
    unsigned char status_var;

  private:
    void copy(const mcpsPurgeConf& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const mcpsPurgeConf&);

  public:
    mcpsPurgeConf(const char *name=NULL, int kind=0);
    mcpsPurgeConf(const mcpsPurgeConf& other);
    virtual ~mcpsPurgeConf();
    mcpsPurgeConf& operator=(const mcpsPurgeConf& other);
    virtual mcpsPurgeConf *dup() const {return new mcpsPurgeConf(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual unsigned char getStatus() const;
    virtual void setStatus(unsigned char status);
};

inline void doPacking(cCommBuffer *b, mcpsPurgeConf& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, mcpsPurgeConf& obj) {obj.parsimUnpack(b);}


#endif // ifndef _MCPSDATA_M_H_

